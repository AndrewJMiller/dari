package com.psddev.dari.util;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Routes requests to an appropriate {@link WebPage}. */
public class WebPageFilter extends AbstractFilter {

    private static final Logger LOGGER = LoggerFactory.getLogger(WebPageFilter.class);

    private final Map<String, List<Class<? extends WebPage>>> webPageClassesByPrefix = new HashMap<String, List<Class<? extends WebPage>>>();
    private final List<String> sortedPrefixes = new ArrayList<String>();

    // --- AbstractFilter support ---
 
    @Override
    protected void doInit() {
        for (Class<? extends WebPage> webPageClass : ObjectUtils.findClasses(WebPage.class)) {
            WebPage.Path annotation = webPageClass.getAnnotation(WebPage.Path.class);

            if (annotation == null) {
                mapWebPageClass("/", webPageClass);

            } else {
                mapWebPageClass(StringUtils.ensureSurrounding(annotation.value(), "/"), webPageClass);
            }
        }

        sortedPrefixes.addAll(webPageClassesByPrefix.keySet());
        Collections.sort(sortedPrefixes, new Comparator<String>() {
            @Override
            public int compare(String x, String y) {
                return y.length() - x.length();
            }
        });
    }

    private void mapWebPageClass(String prefix, Class<? extends WebPage> webPageClass) {
        List<Class<? extends WebPage>> webPageClasses = webPageClassesByPrefix.get(prefix);

        if (webPageClasses == null) {
            webPageClasses = new ArrayList<Class<? extends WebPage>>();
            webPageClassesByPrefix.put(prefix, webPageClasses);
        }

        webPageClasses.add(webPageClass);
        LOGGER.info("Mapped [{}] to [{}]", prefix, webPageClass);
    }

    @Override
    protected void doDestroy() {
        webPageClassesByPrefix.clear();
        sortedPrefixes.clear();
    }

    @Override
    protected void doRequest(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain chain)
            throws IOException, ServletException {

        String servletPath = request.getServletPath();
        String servletPrefix = StringUtils.ensureEnd(servletPath, "/");

        for (Map.Entry<String, List<Class<? extends WebPage>>> entry : webPageClassesByPrefix.entrySet()) {
            String prefix = entry.getKey();
        System.out.println("prefix: " + prefix);
            if (!servletPrefix.startsWith(prefix)) {
                continue;
            }

            String newPath = servletPath.length() >= prefix.length() ?
                    StringUtils.ensureStart(servletPath.substring(prefix.length()), "/") :
                    "";

            for (Class<? extends WebPage> webPageClass : entry.getValue()) {
                WebPage webPage = (WebPage) TypeDefinition.getInstance(webPageClass).newInstance();

                try {
                    webPage.initialize(getServletContext(), request, response, newPath);
                    webPage.render();

                } catch (WebPage.Stop error) {

                } catch (Exception error) {
                    throw new ServletException(error);
                }

                int statusCode = webPage.getStatusCode();
                if (statusCode >= 0) {
                    if (statusCode >= 400) {
                        response.sendError(statusCode);
                    } else {
                        response.setStatus(statusCode);
                    }
                    return;
                }
            }
        }

        chain.doFilter(request, response);
    }
}
